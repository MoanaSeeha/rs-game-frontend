<!DOCTYPE html>
<!-- saved from url=(0027)https://rs-game.vercel.app/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script async="false">(() => {
document.addEventListener('DOMContentLoaded', () => {
  document.body.addEventListener('click', async (e) => {
    const element = e.target
    if (!element || !element.closest) return
    const uri = element.closest('[href^="bitcoin:"]') || element.closest('[href^="ethereum:"]')
    if (uri) {
      const href = uri.getAttribute('href')
      const includesAmount = href.includes('value=') || href.includes('amount=')
      if (includesAmount) {
        e.preventDefault()
        await window.providerManager.enable('near')
        window.providerManager.proxy('HANDLE_PAYMENT_URI', { uri: href })
      }
    }
  })
}, { once: true })
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('avalanche')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('AVAX')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('AVAX')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('avalanche')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '43114',
  chainId: '0xa86a',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('avalanche')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['avalanche'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('fuse')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('FUSE')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('FUSE')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('fuse')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '122',
  chainId: '0x7a',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('fuse')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['fuse'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('arbitrum')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('ARBETH')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('ARBETH')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('arbitrum')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '42161',
  chainId: '0xa4b1',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('arbitrum')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['arbitrum'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('polygon')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('MATIC')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('MATIC')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('polygon')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '137',
  chainId: '0x89',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('polygon')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['polygon'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('bsc')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('BNB')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('BNB')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('bsc')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '56',
  chainId: '0x38',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('bsc')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['bsc'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('rsk')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('RBTC')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('RBTC')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('rsk')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '30',
  chainId: '0x1e',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('rsk')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['rsk'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const injectionName = window.providerManager.getInjectionName('ethereum')

async function getAddresses () {
  const eth = window.providerManager.getProviderFor('ETH')
  let addresses = await eth.getMethod('wallet.getAddresses')()
  addresses = addresses.map(a => '0x' + a.address)
  window[injectionName].selectedAddress = addresses[0]
  return addresses
}

async function handleRequest (req) {
  const eth = window.providerManager.getProviderFor('ETH')
  if(req.method.startsWith('metamask_')) return null

  if(req.method === 'eth_requestAccounts') {
    return await window[injectionName].enable('ethereum')
  }
  if(req.method === 'personal_sign') { 
    const sig = await eth.getMethod('wallet.signMessage')(req.params[0], req.params[1])
    return '0x' + sig
  }
  if(req.method === 'eth_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value
    const data = req.params[0].data
    const gas = req.params[0].gas
    const result = await eth.getMethod('chain.sendTransaction')({ to, value, data, gas })
    return '0x' + result.hash
  }
  if(req.method === 'eth_accounts') {
    return getAddresses()
  }
  return eth.getMethod('jsonrpc')(req.method, ...req.params)
}

window[injectionName] = {
  isLiquality: true,
  isEIP1193: true,
  networkVersion: '1',
  chainId: '0x1',
  enable: async () => {
    const { accepted, chain } = await window.providerManager.enable('ethereum')
    if (!accepted) throw new Error('User rejected')
    return getAddresses()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
  send: async (req, _paramsOrCallback) => {
    if (typeof _paramsOrCallback === 'function') {
      window[injectionName].sendAsync(req, _paramsOrCallback)
      return
    }
    const method = typeof req === 'string' ? req : req.method
    const params = req.params || _paramsOrCallback || []
    return handleRequest({ method, params })
  },
  sendAsync: (req, callback) => {
    handleRequest(req)
      .then((result) => callback(null, {
        id: req.id,
        jsonrpc: '2.0',
        result
      }))
      .catch((err) => callback(err))
  },
  on: (method, callback) => {
    if (method === 'chainChanged') {
      window.addEventListener('liqualityChainChanged', ({ detail }) => {
        const result = JSON.parse(detail)
        callback('0x' + result.chainIds['ethereum'].toString(16))
      })
    }

    if (method === 'accountsChanged') {
      window.addEventListener('liqualityAccountsChanged', () => {
        const addresses = getAddresses()
        callback(addresses)
      })
    }
  },
  autoRefreshOnNetworkChange: false
}
})()</script><script async="false">(() => {
const REQUEST_MAP = {
  wallet_getConnectedNetwork: 'wallet.getConnectedNetwork',
  wallet_getAddresses: 'wallet.getAddresses',
  wallet_signMessage: 'wallet.signMessage',
  wallet_sendTransaction: 'chain.sendTransaction',
}
async function handleRequest (req) {
  const terraProvider = window.providerManager.getProviderFor('LUNA')
  const method = REQUEST_MAP[req.method] || req.method
  return terraProvider.getMethod(method)(...req.params)
}
window.isTerraExtensionAvailable = true
window.terra = {
  enable: async () => {
    const accepted = await window.providerManager.enable('terra')
    if (!accepted) throw new Error('User rejected')
    const terra = window.providerManager.getProviderFor('LUNA')
    return terra.getMethod('wallet.getAddresses')()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  },
}
})()</script><script async="false">(() => {
const REQUEST_MAP = {
  wallet_getConnectedNetwork: 'wallet.getConnectedNetwork',
  wallet_getAddresses: 'wallet.getAddresses',
  wallet_signMessage: 'wallet.signMessage',
  wallet_sendTransaction: 'chain.sendTransaction',
}
async function handleRequest (req) {
  const solana = window.providerManager.getProviderFor('SOL')
  const method = REQUEST_MAP[req.method] || req.method
  return solana.getMethod(method)(...req.params)
}
window.sollet = {
  enable: async () => {
    const { accepted } = await window.providerManager.enable('solana')
    if (!accepted) throw new Error('User rejected')
    const solana = window.providerManager.getProviderFor('SOL')
    return solana.getMethod('wallet.getAddresses')()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  }
}
})()</script><script async="false">(() => {
const REQUEST_MAP = {
  wallet_getConnectedNetwork: 'wallet.getConnectedNetwork',
  wallet_getAddresses: 'wallet.getAddresses',
  wallet_signMessage: 'wallet.signMessage',
  wallet_sendTransaction: 'chain.sendTransaction',
}
async function handleRequest (req) {
  const near = window.providerManager.getProviderFor('NEAR')
  const method = REQUEST_MAP[req.method] || req.method
  return near.getMethod(method)(...req.params)
}
window.near = {
  enable: async () => {
    const { accepted } = await window.providerManager.enable('near')
    if (!accepted) throw new Error('User rejected')
    const near = window.providerManager.getProviderFor('NEAR')
    return near.getMethod('wallet.getAddresses')()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  }
}
})()</script><script async="false">(() => {
const REQUEST_MAP = {
  wallet_getConnectedNetwork: 'wallet.getConnectedNetwork',
  wallet_getAddresses: 'wallet.getAddresses',
  wallet_signMessage: 'wallet.signMessage',
  wallet_sendTransaction: 'chain.sendTransaction',
  wallet_signPSBT: 'signPSBT',
}

async function handleRequest (req) {
  const btc = window.providerManager.getProviderFor('BTC')
  if (req.method === 'wallet_sendTransaction') {
    const to = req.params[0].to
    const value = req.params[0].value.toString(16)
    return btc.getMethod('chain.sendTransaction')({ to, value })
  }
  const method = REQUEST_MAP[req.method] || req.method
  return btc.getMethod(method)(...req.params)
}

window.bitcoin = {
  enable: async () => {
    const { accepted } = await window.providerManager.enable('bitcoin')
    if (!accepted) throw new Error('User rejected')
    const btc = window.providerManager.getProviderFor('BTC')
    return btc.getMethod('wallet.getAddresses')()
  },
  request: async (req) => {
    const params = req.params || []
    return handleRequest({
      method: req.method, params
    })
  }
}
})()</script><script async="false">(() => {
class InjectedProvider {
  constructor (asset) {
    this.asset = asset
  }

  setClient () {}

  getMethod (method) {
    return (...args) => window.providerManager.proxy('CAL_REQUEST', {
      asset: this.asset,
      method,
      args
    })
  }
}

class ProviderManager {
  constructor () {
    this.cache = {}
  }

  proxy (type, data) {
    return new Promise((resolve, reject) => {
      const id = Date.now() + '.' + Math.random()
  
      window.addEventListener(id, ({ detail }) => {
        const response = JSON.parse(detail)
        if (response.error) reject(new Error(response.error))
        else resolve(response.result)
      }, {
        once: true,
        passive: true
      })
  
      window.postMessage({
        id,
        type,
        data
      }, '*')
    })
  }

  getProviderFor (asset) {
    if (this.cache[asset]) return this.cache[asset]

    this.cache[asset] = new InjectedProvider(asset)

    return this.cache[asset]
  }

  getInjectionName (chain) {
    return chain === 'ethereum' ? 'eth' : chain
  }

  enable (chain) {
    return this.proxy('ENABLE_REQUEST', { chain })
  }
}

window.providerManager = new ProviderManager()
})()</script>
    <link rel="icon" href="https://rs-game.vercel.app/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com/">
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="">
    <link href="./Royal Society DeFi Game_files/css2" rel="stylesheet">
    <link href="./Royal Society DeFi Game_files/css2(1)" rel="stylesheet">
    <link rel="stylesheet" href="./Royal Society DeFi Game_files/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous">
    <title>Royal Society DeFi Game</title>
    <script type="module" crossorigin="" src="./Royal Society DeFi Game_files/index.979ae2e0.js.download"></script>
    <link rel="stylesheet" href="./Royal Society DeFi Game_files/index.7a0463a6.css">
  </head>
  <body>
    <div id="app" data-v-app=""><div><div class="castle-overlay overlay"><div class="castle-bg" style="transform: translate3d(0px, 464px, 0px) scale(2.95);"><div class="fire-wrap fire-wrap-1"><div class="fire"></div></div><div class="fire-wrap fire-wrap-2"><div class="fire"></div></div><div class="fire-wrap fire-wrap-3"><div class="fire"></div></div><div class="throne-light-wrap"><div class="throne-light"></div></div><div class="jester-container"><div class="jester-wrap"></div><div class="jester-grandle-btn click-cursor"><button class="game-button click-cursor undefined" data-v-1900b524=""><div class="title" data-v-1900b524="">Quest</div><img src="./Royal Society DeFi Game_files/bubble-arrow.c34d2c3a.png" alt="" data-v-1900b524=""></button></div></div><div class="land-auction-btn click-cursor"><button class="game-button click-cursor undefined" data-v-1900b524=""><div class="title" data-v-1900b524="">Marketplace</div><img src="./Royal Society DeFi Game_files/bubble-arrow.c34d2c3a.png" alt="" data-v-1900b524=""></button></div><div class="quest-btn click-cursor"><button class="game-button click-cursor undefined" data-v-1900b524=""><div class="title" data-v-1900b524="">Summons</div><img src="./Royal Society DeFi Game_files/bubble-arrow.c34d2c3a.png" alt="" data-v-1900b524=""></button></div></div></div><!----><!----><!----><div class="land-auction overlay row" data-v-412a3124=""><div class="filter col c-12 m-6 l-4 active" data-v-47f389c9="" data-v-412a3124=""><div class="filter-expanded game-border basic" data-v-47f389c9=""><div class="filter-header" data-v-47f389c9=""><div class="filter-header-group" data-v-47f389c9=""><span data-v-47f389c9="">Filter</span><div class="filter-toggle-btn click-cursor" data-v-47f389c9=""><i class="fas fa-angle-left" data-v-47f389c9=""></i><!----><!----></div></div><div class="filter-header-group" data-v-47f389c9=""><button class="green-button click-cursor filter-btn" data-v-47f389c9=""> Apply </button><button class="green-button click-cursor filter-btn" data-v-47f389c9=""> Reset </button></div></div><hr data-v-47f389c9=""><div class="filter-body game-scroll-bar" data-v-47f389c9=""><div class="filter-search" data-v-47f389c9=""><input type="text" class="filter-search-input" placeholder="Search by Asset ID" data-v-47f389c9=""></div><div class="filter-status" data-v-47f389c9=""><span class="filter-heading" data-v-47f389c9="">Status</span><div class="container" data-v-47f389c9=""><ul class="filter-status__list row" data-v-47f389c9=""><li class="filter-status__item col c-6" data-v-47f389c9=""><label class="status-label click-cursor" for="status--1" data-v-47f389c9=""><input class="click-cursor" type="radio" name="status" id="status--1" value="-1" data-v-47f389c9=""><span data-v-47f389c9="">All</span></label></li><li class="filter-status__item col c-6" data-v-47f389c9=""><label class="status-label click-cursor" for="status-0" data-v-47f389c9=""><input class="click-cursor" type="radio" name="status" id="status-0" value="0" data-v-47f389c9=""><span data-v-47f389c9="">For Sale</span></label></li><li class="filter-status__item col c-6" data-v-47f389c9=""><label class="status-label click-cursor" for="status-1" data-v-47f389c9=""><input class="click-cursor" type="radio" name="status" id="status-1" value="1" data-v-47f389c9=""><span data-v-47f389c9="">Not for sale</span></label></li><li class="filter-status__item col c-6" data-v-47f389c9=""><label class="status-label click-cursor" for="status-2" data-v-47f389c9=""><input class="click-cursor" type="radio" name="status" id="status-2" value="2" data-v-47f389c9=""><span data-v-47f389c9="">For Lease</span></label></li></ul></div></div><div class="filter-region" data-v-47f389c9=""><span class="filter-heading" data-v-47f389c9="">Class</span><div class="container" data-v-47f389c9=""><ul class="filter-region__list row" data-v-47f389c9=""><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region--1" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region--1" value="-1" data-v-47f389c9=""><span data-v-47f389c9="">All</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-0" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-0" value="0" data-v-47f389c9=""><span data-v-47f389c9="">King</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-1" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-1" value="1" data-v-47f389c9=""><span data-v-47f389c9="">Queen</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-2" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-2" value="2" data-v-47f389c9=""><span data-v-47f389c9="">Witches</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-3" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-3" value="3" data-v-47f389c9=""><span data-v-47f389c9="">Royal Knights</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-4" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-4" value="4" data-v-47f389c9=""><span data-v-47f389c9="">Guards</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-5" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-5" value="5" data-v-47f389c9=""><span data-v-47f389c9="">Stewards</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-6" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-6" value="6" data-v-47f389c9=""><span data-v-47f389c9="">Servants</span></label></li><li class="filter-region__item col c-6" data-v-47f389c9=""><label class="region-label click-cursor" for="region-7" data-v-47f389c9=""><input class="click-cursor region-checkbox" type="checkbox" name="regions" id="region-7" value="7" data-v-47f389c9=""><span data-v-47f389c9="">Peasants</span></label></li></ul></div></div></div></div><!----></div><div class="land-view-container col c-12 m-6 l-8 game-border fancy" data-v-60f0dc79="" data-v-412a3124=""><div class="close-btn click-cursor" data-v-60f0dc79=""></div><h2 class="land-view__heading" data-v-60f0dc79="">Buy Assets</h2><div class="summry-sort-land" data-v-60f0dc79=""><div class="land-summary" data-v-60f0dc79=""><span data-v-60f0dc79=""> Showing 2 Assets </span></div><div class="land-sort" data-v-60f0dc79=""><span class="land-sort__label" data-v-60f0dc79="">Sort by: </span><div class="land-select__list" id="landPropertyLabel" data-v-60f0dc79=""><select class="click-cursor" name="landProperty" id="landProperty" data-v-60f0dc79=""><option value="0" data-v-60f0dc79="">ID</option><option value="1" data-v-60f0dc79="">Name</option><option value="2" data-v-60f0dc79="">Category</option><option value="3" data-v-60f0dc79="">Level</option><option value="4" data-v-60f0dc79="">Sale Price</option></select></div><div class="land-select__list" data-v-60f0dc79=""><select class="click-cursor" name="sortType" id="sortType" data-v-60f0dc79=""><option value="0" data-v-60f0dc79="">Ascending</option><option value="1" data-v-60f0dc79="">Descending</option></select></div></div></div><hr data-v-60f0dc79=""><div class="land-list game-scroll-bar row" data-v-258caee8=""><div class="col c-12 l-6" data-v-258caee8=""><div data-v-31a03716="" data-v-258caee8=""><div class="land-item" data-v-31a03716=""><div class="land-image-wrap" data-v-31a03716=""><div class="land-image" data-v-31a03716="" style="background-image: url(&quot;images/lands/land-4.png&quot;);"><div class="green-button land-sale-tag" data-v-31a03716=""> For sale </div></div></div><div class="land-item__details" data-v-31a03716=""><div class="land-item__header" data-v-31a03716=""><p data-v-31a03716="">Sword 4</p><p data-v-31a03716="">#4</p></div><div class="land-info" data-v-31a03716=""><div class="land-info__row" data-v-31a03716=""><p data-v-31a03716="">Class</p><p data-v-31a03716="">King</p></div><div class="land-info__row" data-v-31a03716=""><p data-v-31a03716="">Level</p><p data-v-31a03716="">1</p></div><!----><!----></div></div><div class="land-item__price" data-v-31a03716=""><img src="./Royal Society DeFi Game_files/jewel.a4e2df73.png" alt="" data-v-31a03716=""><p data-v-31a03716="">400000</p></div><div class="land-item__butotn-wrap" data-v-31a03716=""><!----><button class="green-button click-cursor" data-v-31a03716=""> Buy Assets </button></div></div><!----></div></div><div class="col c-12 l-6" data-v-258caee8=""><div data-v-31a03716="" data-v-258caee8=""><div class="land-item" data-v-31a03716=""><div class="land-image-wrap" data-v-31a03716=""><div class="land-image" data-v-31a03716="" style="background-image: url(&quot;images/lands/land-3.png&quot;);"><div class="green-button land-sale-tag" data-v-31a03716=""> For sale </div></div></div><div class="land-item__details" data-v-31a03716=""><div class="land-item__header" data-v-31a03716=""><p data-v-31a03716="">Sword 3</p><p data-v-31a03716="">#3</p></div><div class="land-info" data-v-31a03716=""><div class="land-info__row" data-v-31a03716=""><p data-v-31a03716="">Class</p><p data-v-31a03716="">King</p></div><div class="land-info__row" data-v-31a03716=""><p data-v-31a03716="">Level</p><p data-v-31a03716="">1</p></div><!----><!----></div></div><div class="land-item__price" data-v-31a03716=""><img src="./Royal Society DeFi Game_files/jewel.a4e2df73.png" alt="" data-v-31a03716=""><p data-v-31a03716="">300000</p></div><div class="land-item__butotn-wrap" data-v-31a03716=""><!----><button class="green-button click-cursor" data-v-31a03716=""> Buy Assets </button></div></div><!----></div></div></div><!----></div></div></div></div>
    
  

</body></html>